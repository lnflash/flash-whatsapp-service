import { Injectable } from '@nestjs/common';
import {
  BasePlugin,
  CommandDefinition,
  ParsedCommand,
  CommandContext,
  PluginResponse,
} from '../interfaces/plugin.interface';
import { RedisService } from '../../redis/redis.service';

interface TranslationCache {
  text: string;
  sourceLang: string;
  targetLang: string;
  translation: string;
  timestamp: number;
}

interface LanguageDetection {
  language: string;
  confidence: number;
}

/**
 * Language translation plugin for multilingual communication
 */
@Injectable()
export class TranslationPlugin extends BasePlugin {
  id = 'translation';
  name = 'Language Translation';
  description = 'Break language barriers with instant translation';
  version = '1.0.0';

  // Supported languages (subset for demo)
  private languages: Record<string, string> = {
    en: 'English',
    es: 'Spanish',
    fr: 'French',
    de: 'German',
    it: 'Italian',
    pt: 'Portuguese',
    ru: 'Russian',
    ja: 'Japanese',
    ko: 'Korean',
    zh: 'Chinese',
    ar: 'Arabic',
    hi: 'Hindi',
    nl: 'Dutch',
    pl: 'Polish',
    tr: 'Turkish',
    vi: 'Vietnamese',
    th: 'Thai',
    id: 'Indonesian',
    ms: 'Malay',
    tl: 'Tagalog',
  };

  // Common phrases for quick translation
  private commonPhrases: Record<string, Record<string, string>> = {
    hello: {
      es: 'Hola',
      fr: 'Bonjour',
      de: 'Hallo',
      it: 'Ciao',
      pt: 'Ol√°',
      ru: '–ü—Ä–∏–≤–µ—Ç',
      ja: '„Åì„Çì„Å´„Å°„ÅØ',
      ko: 'ÏïàÎÖïÌïòÏÑ∏Ïöî',
      zh: '‰Ω†Â•Ω',
      ar: 'ŸÖÿ±ÿ≠ÿ®ÿß',
      hi: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á',
    },
    thanks: {
      es: 'Gracias',
      fr: 'Merci',
      de: 'Danke',
      it: 'Grazie',
      pt: 'Obrigado',
      ru: '–°–ø–∞—Å–∏–±–æ',
      ja: '„ÅÇ„Çä„Åå„Å®„ÅÜ',
      ko: 'Í∞êÏÇ¨Ìï©ÎãàÎã§',
      zh: 'Ë∞¢Ë∞¢',
      ar: 'ÿ¥ŸÉÿ±ÿß',
      hi: '‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶',
    },
    yes: {
      es: 'S√≠',
      fr: 'Oui',
      de: 'Ja',
      it: 'S√¨',
      pt: 'Sim',
      ru: '–î–∞',
      ja: '„ÅØ„ÅÑ',
      ko: 'ÎÑ§',
      zh: 'ÊòØ',
      ar: 'ŸÜÿπŸÖ',
      hi: '‡§π‡§æ‡§Å',
    },
    no: {
      es: 'No',
      fr: 'Non',
      de: 'Nein',
      it: 'No',
      pt: 'N√£o',
      ru: '–ù–µ—Ç',
      ja: '„ÅÑ„ÅÑ„Åà',
      ko: 'ÏïÑÎãàÏöî',
      zh: '‰∏ç',
      ar: 'ŸÑÿß',
      hi: '‡§®‡§π‡•Ä‡§Ç',
    },
  };

  commands: CommandDefinition[] = [
    {
      trigger: 'translate',
      aliases: ['tr', 'trans'],
      patterns: [
        /translate\s+(.+)/i,
        /tr\s+(.+)/i,
        /(.+)\s+to\s+(\w+)$/i,
        /what is\s+(.+)\s+in\s+(\w+)/i,
      ],
      description: 'Translate text to another language',
      examples: ['translate hello to spanish', 'tr bonjour', 'what is thank you in japanese'],
      groupSupported: true,
      requiresAuth: false,
    },
    {
      trigger: 'detect',
      patterns: [/detect language\s+(.+)/i, /what language is\s+(.+)/i],
      description: 'Detect the language of text',
      examples: ['detect language „Åì„Çì„Å´„Å°„ÅØ', 'what language is bonjour'],
      groupSupported: true,
      requiresAuth: false,
    },
    {
      trigger: 'languages',
      patterns: [/show languages/i, /supported languages/i],
      description: 'Show supported languages',
      examples: ['languages'],
      groupSupported: true,
      requiresAuth: false,
    },
    {
      trigger: 'autotranslate',
      patterns: [/auto translate/i, /enable translation/i],
      description: 'Enable automatic translation in group',
      examples: ['autotranslate on', 'autotranslate off'],
      groupSupported: true,
      requiresAuth: false,
    },
  ];

  constructor(private redisService: RedisService) {
    super();
  }

  async handleCommand(command: ParsedCommand, context: CommandContext): Promise<PluginResponse> {
    switch (command.trigger.toLowerCase()) {
      case 'translate':
      case 'tr':
      case 'trans':
        return this.handleTranslate(command, context);
      case 'detect':
        return this.handleDetect(command, context);
      case 'languages':
        return this.showLanguages();
      case 'autotranslate':
        return this.handleAutoTranslate(command, context);
      default:
        // Check for pattern-based translation
        if (
          command.rawText.match(/(.+)\s+to\s+(\w+)$/i) ||
          command.rawText.match(/what is\s+(.+)\s+in\s+(\w+)/i)
        ) {
          return this.handleTranslate(command, context);
        }
        return {
          text: '‚ùì Unknown translation command',
        };
    }
  }

  private async handleTranslate(
    command: ParsedCommand,
    context: CommandContext,
  ): Promise<PluginResponse> {
    let text: string;
    let targetLang: string | undefined;

    // Parse different command formats
    const toMatch = command.rawText.match(/(.+)\s+to\s+(\w+)$/i);
    const whatIsMatch = command.rawText.match(/what is\s+(.+)\s+in\s+(\w+)/i);

    if (toMatch) {
      text = toMatch[1]
        .replace(/^translate\s+/i, '')
        .replace(/^tr\s+/i, '')
        .trim();
      targetLang = this.parseLanguageCode(toMatch[2]);
    } else if (whatIsMatch) {
      text = whatIsMatch[1].trim();
      targetLang = this.parseLanguageCode(whatIsMatch[2]);
    } else {
      // Simple format: translate [text]
      text = command.args.join(' ') || command.rawText.replace(/^(translate|tr|trans)\s+/i, '');

      // Try to detect if last word is a language
      const words = text.split(' ');
      const lastWord = words[words.length - 1].toLowerCase();
      const langCode = this.parseLanguageCode(lastWord);

      if (langCode && words.length > 1) {
        targetLang = langCode;
        text = words.slice(0, -1).join(' ');
      }
    }

    if (!text) {
      return {
        text: '‚ùå Please provide text to translate!\n\nExample: translate hello to spanish',
      };
    }

    // Check cache
    const cacheKey = `translate:${text}:${targetLang || 'auto'}`;
    const cached = await this.redisService.get(cacheKey);

    if (cached) {
      const cache: TranslationCache = JSON.parse(cached);
      return this.formatTranslationResponse(cache);
    }

    // Detect source language
    const sourceLang = this.detectLanguage(text);

    // If no target language specified, translate to English or from English
    if (!targetLang) {
      targetLang = sourceLang.language === 'en' ? 'es' : 'en';
    }

    // Perform translation (simulated)
    const translation = await this.translateText(text, sourceLang.language, targetLang);

    // Cache result
    const result: TranslationCache = {
      text,
      sourceLang: sourceLang.language,
      targetLang,
      translation,
      timestamp: Date.now(),
    };

    await this.redisService.set(cacheKey, JSON.stringify(result), 3600); // 1 hour cache

    return this.formatTranslationResponse(result);
  }

  private async handleDetect(
    command: ParsedCommand,
    context: CommandContext,
  ): Promise<PluginResponse> {
    const text =
      command.args.join(' ') ||
      command.rawText.replace(/^(detect language|what language is)\s+/i, '');

    if (!text) {
      return {
        text: '‚ùå Please provide text to detect language!',
      };
    }

    const detection = this.detectLanguage(text);
    const languageName = this.languages[detection.language] || 'Unknown';

    let response = `üîç *Language Detection*\n\n`;
    response += `Text: "${text}"\n`;
    response += `Language: ${languageName} (${detection.language})\n`;
    response += `Confidence: ${Math.round(detection.confidence * 100)}%`;

    if (detection.confidence < 0.7) {
      response += '\n\n‚ö†Ô∏è Low confidence - the text might be too short or mixed languages.';
    }

    return {
      text: response,
      showTyping: true,
      delay: 300,
    };
  }

  private showLanguages(): PluginResponse {
    let text = 'üåç *Supported Languages*\n\n';

    const langs = Object.entries(this.languages).sort((a, b) => a[1].localeCompare(b[1]));

    langs.forEach(([code, name]) => {
      text += `‚Ä¢ ${name} (${code})\n`;
    });

    text += '\nüí° Use language name or code in translation commands.';

    return {
      text,
      showTyping: true,
      delay: 400,
    };
  }

  private async handleAutoTranslate(
    command: ParsedCommand,
    context: CommandContext,
  ): Promise<PluginResponse> {
    if (!context.isGroup) {
      return {
        text: '‚ùå Auto-translate is only available in group chats!',
      };
    }

    const args = command.args.join(' ').toLowerCase();
    const enable = args.includes('on') || args.includes('enable');
    const disable = args.includes('off') || args.includes('disable');

    if (!enable && !disable) {
      return {
        text: '‚ùå Please specify "on" or "off"\n\nExample: autotranslate on',
      };
    }

    const settingKey = `autotranslate:${context.groupId}`;

    if (enable) {
      // Store user's preferred language
      const userLang = await this.getUserLanguage(context.userId);
      await this.redisService.set(settingKey, 'enabled', 86400 * 7); // 7 days

      return {
        text:
          `üåê *Auto-translate enabled!*\n\n` +
          `Messages in foreign languages will be automatically translated.\n` +
          `Your language: ${this.languages[userLang] || 'English'}\n\n` +
          `To disable: autotranslate off`,
      };
    } else {
      await this.redisService.del(settingKey);

      return {
        text: 'üåê Auto-translate disabled.',
      };
    }
  }

  private formatTranslationResponse(cache: TranslationCache): PluginResponse {
    const sourceLangName = this.languages[cache.sourceLang] || cache.sourceLang;
    const targetLangName = this.languages[cache.targetLang] || cache.targetLang;

    let text = `üåê *Translation*\n\n`;
    text += `${this.getLanguageEmoji(cache.sourceLang)} ${sourceLangName}: "${cache.text}"\n`;
    text += `${this.getLanguageEmoji(cache.targetLang)} ${targetLangName}: "${cache.translation}"`;

    // Add pronunciation guide for certain languages
    const pronunciation = this.getPronunciation(cache.translation, cache.targetLang);
    if (pronunciation) {
      text += `\nüîä Pronunciation: ${pronunciation}`;
    }

    return {
      text,
      showTyping: true,
      delay: 500,
    };
  }

  private detectLanguage(text: string): LanguageDetection {
    // Simple language detection based on character sets and common words
    // In production, this would use a proper language detection library

    // Check for specific scripts
    if (/[\u4e00-\u9fff]/.test(text)) return { language: 'zh', confidence: 0.9 };
    if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return { language: 'ja', confidence: 0.9 };
    if (/[\uac00-\ud7af]/.test(text)) return { language: 'ko', confidence: 0.9 };
    if (/[\u0600-\u06ff]/.test(text)) return { language: 'ar', confidence: 0.9 };
    if (/[\u0400-\u04ff]/.test(text)) return { language: 'ru', confidence: 0.9 };
    if (/[\u0900-\u097f]/.test(text)) return { language: 'hi', confidence: 0.9 };

    // Check common words
    const lowerText = text.toLowerCase();

    if (lowerText.includes('hello') || lowerText.includes('the') || lowerText.includes('is')) {
      return { language: 'en', confidence: 0.8 };
    }
    if (lowerText.includes('hola') || lowerText.includes('el') || lowerText.includes('es')) {
      return { language: 'es', confidence: 0.8 };
    }
    if (lowerText.includes('bonjour') || lowerText.includes('le') || lowerText.includes('est')) {
      return { language: 'fr', confidence: 0.8 };
    }
    if (lowerText.includes('hallo') || lowerText.includes('der') || lowerText.includes('ist')) {
      return { language: 'de', confidence: 0.8 };
    }

    // Default to English with low confidence
    return { language: 'en', confidence: 0.5 };
  }

  private async translateText(
    text: string,
    sourceLang: string,
    targetLang: string,
  ): Promise<string> {
    // Check common phrases first
    const lowerText = text.toLowerCase().trim();

    for (const [phrase, translations] of Object.entries(this.commonPhrases)) {
      if (lowerText === phrase && translations[targetLang]) {
        return translations[targetLang];
      }
    }

    // Simulated translation for demo
    // In production, this would call a translation API
    const translations: Record<string, Record<string, string>> = {
      'hello world': {
        es: 'Hola mundo',
        fr: 'Bonjour le monde',
        de: 'Hallo Welt',
        it: 'Ciao mondo',
        pt: 'Ol√° mundo',
        ja: '„Éè„É≠„Éº„ÉØ„Éº„É´„Éâ',
        ko: 'Ìó¨Î°ú ÏõîÎìú',
        zh: '‰Ω†Â•Ω‰∏ñÁïå',
      },
      'good morning': {
        es: 'Buenos d√≠as',
        fr: 'Bonjour',
        de: 'Guten Morgen',
        it: 'Buongiorno',
        pt: 'Bom dia',
        ja: '„Åä„ÅØ„Çà„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô',
        ko: 'Ï¢ãÏùÄ ÏïÑÏπ®',
        zh: 'Êó©‰∏äÂ•Ω',
      },
      'how are you': {
        es: '¬øC√≥mo est√°s?',
        fr: 'Comment allez-vous?',
        de: 'Wie geht es dir?',
        it: 'Come stai?',
        pt: 'Como voc√™ est√°?',
        ja: 'ÂÖÉÊ∞ó„Åß„Åô„Åã',
        ko: 'Ïñ¥ÎñªÍ≤å ÏßÄÎÇ¥ÏÑ∏Ïöî?',
        zh: '‰Ω†Â•ΩÂêóÔºü',
      },
    };

    const key = lowerText;
    if (translations[key] && translations[key][targetLang]) {
      return translations[key][targetLang];
    }

    // Simple word-by-word translation for demo
    const wordTranslations: Record<string, Record<string, string>> = {
      i: { es: 'yo', fr: 'je', de: 'ich', it: 'io', pt: 'eu' },
      you: { es: 't√∫', fr: 'tu', de: 'du', it: 'tu', pt: 'voc√™' },
      love: { es: 'amor', fr: 'amour', de: 'liebe', it: 'amore', pt: 'amor' },
      bitcoin: { es: 'bitcoin', fr: 'bitcoin', de: 'bitcoin', it: 'bitcoin', pt: 'bitcoin' },
    };

    const words = text.split(' ');
    const translatedWords = words.map((word) => {
      const lower = word.toLowerCase();
      if (wordTranslations[lower] && wordTranslations[lower][targetLang]) {
        return wordTranslations[lower][targetLang];
      }
      return word;
    });

    return translatedWords.join(' ');
  }

  private parseLanguageCode(input: string): string | undefined {
    const lower = input.toLowerCase();

    // Check if it's already a valid code
    if (this.languages[lower]) {
      return lower;
    }

    // Check language names
    for (const [code, name] of Object.entries(this.languages)) {
      if (name.toLowerCase() === lower) {
        return code;
      }
    }

    // Check common variations
    const variations: Record<string, string> = {
      spanish: 'es',
      english: 'en',
      french: 'fr',
      german: 'de',
      italian: 'it',
      portuguese: 'pt',
      russian: 'ru',
      japanese: 'ja',
      korean: 'ko',
      chinese: 'zh',
      arabic: 'ar',
      hindi: 'hi',
    };

    return variations[lower];
  }

  private getLanguageEmoji(langCode: string): string {
    const flags: Record<string, string> = {
      en: 'üá¨üáß',
      es: 'üá™üá∏',
      fr: 'üá´üá∑',
      de: 'üá©üá™',
      it: 'üáÆüáπ',
      pt: 'üáµüáπ',
      ru: 'üá∑üá∫',
      ja: 'üáØüáµ',
      ko: 'üá∞üá∑',
      zh: 'üá®üá≥',
      ar: 'üá∏üá¶',
      hi: 'üáÆüá≥',
      nl: 'üá≥üá±',
      pl: 'üáµüá±',
      tr: 'üáπüá∑',
      vi: 'üáªüá≥',
      th: 'üáπüá≠',
      id: 'üáÆüá©',
      ms: 'üá≤üáæ',
      tl: 'üáµüá≠',
    };

    return flags[langCode] || 'üåê';
  }

  private getPronunciation(text: string, langCode: string): string | undefined {
    // Simple pronunciation guide for demo
    const pronunciations: Record<string, Record<string, string>> = {
      „Åì„Çì„Å´„Å°„ÅØ: { ja: 'kon-ni-chi-wa' },
      „ÅÇ„Çä„Åå„Å®„ÅÜ: { ja: 'a-ri-ga-t≈ç' },
      ‰Ω†Â•Ω: { zh: 'n«ê h«éo' },
      Ë∞¢Ë∞¢: { zh: 'xi√® xie' },
      ÏïàÎÖïÌïòÏÑ∏Ïöî: { ko: 'an-nyeong-ha-se-yo' },
      Í∞êÏÇ¨Ìï©ÎãàÎã§: { ko: 'gam-sa-ham-ni-da' },
    };

    return pronunciations[text]?.[langCode];
  }

  private async getUserLanguage(userId: string): Promise<string> {
    const key = `user:language:${userId}`;
    const lang = await this.redisService.get(key);
    return lang || 'en';
  }
}
